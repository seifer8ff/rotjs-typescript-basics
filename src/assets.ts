import { Assets, AssetsManifest } from "pixi.js";
import * as PIXI from "pixi.js";
import { Tile, Biome, TileType, BiomeId, BaseTileKey } from "./tile";
import { Season } from "./time-manager";

export interface CachedSprite {
  url: string;
  xOffset: number;
  yOffset: number;
}

export const AssetSeasons = [Season.Spring];

/** List of assets grouped in bundles, for dynamic loading */
let assetsManifest: AssetsManifest = { bundles: [] };

/** Store bundles already loaded */
const loadedBundles: string[] = [];

const tileFormat = new Intl.NumberFormat("en", {
  minimumIntegerDigits: 2,
  useGrouping: false,
});

/** Check if a bundle exists in assetManifest  */
function CheckBundleExists(bundle: string) {
  return !!assetsManifest.bundles.find((b) => b.name === bundle);
}

/** Load assets bundles that have nott been loaded yet */
export async function LoadBundles(bundles: string | string[]) {
  if (typeof bundles === "string") bundles = [bundles];

  // Check bundles requested if they exists
  for (const bundle of bundles) {
    if (!CheckBundleExists(bundle)) {
      throw new Error(`[Assets] Invalid bundle: ${bundle}`);
    }
  }

  // Filter out bundles already loaded
  const loadList = bundles.filter((bundle) => !loadedBundles.includes(bundle));

  // Skip if there is no bundle left to be loaded
  if (!loadList.length) return;

  // Load bundles
  console.log("[Assets] Load:", loadList.join(", "));
  await Assets.loadBundle(loadList);

  // Append loaded bundles to the loaded list
  loadedBundles.push(...loadList);
}

/** Check if all bundles are loaded, return false if any of them is not loaded yet  */
export function AreBundlesLoaded(bundles: string[]) {
  for (const name of bundles) {
    // Return false if a single bundle is not present in the loaded list
    if (!loadedBundles.includes(name)) {
      return false;
    }
  }

  // All provided bundles are loaded
  return true;
}

/** Load the assets json manifest generated by assetpack */
async function FetchAssetsManifest(url: string) {
  const response = await fetch(url);
  const manifest = await response.json();
  if (!manifest.bundles) {
    throw new Error("[Assets] Invalid assets manifest");
  }
  return manifest;
}

/** Initialise and start background loading of all assets */
export async function InitAssets() {
  initPixiOptions();
  console.log("init assets");
  // Load assets manifest
  assetsManifest = await FetchAssetsManifest("public/assets-manifest.json");
  console.log("assets manifest length: " + assetsManifest.bundles.length);

  // Init PixiJS assets with this asset manifest
  await Assets.init({ manifest: assetsManifest, basePath: "public" });

  // Load an initial bundle (can use for loading screen in future)
  await LoadBundles("default");

  // List all existing bundles names
  const allBundles = assetsManifest.bundles.map((item) => item.name);

  // Start up background loading of all bundles
  // Assets.backgroundLoadBundle(allBundles);

  await Assets.backgroundLoadBundle(allBundles);
  console.log("about to process tilesets into tiles");
  ProcessTilesetsIntoTiles();
}

export function initPixiOptions(): void {
  PIXI.BaseTexture.defaultOptions.scaleMode = PIXI.SCALE_MODES.NEAREST;
  PIXI.BaseTexture.defaultOptions.anisotropicLevel = 0;
  PIXI.BaseTexture.defaultOptions.mipmap = PIXI.MIPMAP_MODES.ON;
  PIXI.BaseTexture.defaultOptions.wrapMode = PIXI.WRAP_MODES.CLAMP;
}

export function ProcessTilesetsIntoTiles() {
  console.log("process tilesets into tiles");
  // for each tileset, create new Tile 0 through 47
  Object.keys(Tile.Biomes).forEach((tilesetId: string) => {
    generateTileset(Tile.Biomes[tilesetId]);
  });
  console.log("end result: ", Tile.Tilesets);
}

export function generateTileset(tilesetMeta: Biome) {
  console.log(tilesetMeta);
  let tilesetUrl;
  const autoTilePrefixes = tilesetMeta.autotileAgainst;
  if (autoTilePrefixes?.length) {
    for (let i = 0; i < autoTilePrefixes.length; i++) {
      for (let j = 0; j < 48; j++) {
        tilesetUrl = `${autoTilePrefixes[i].prefix}${tileFormat.format(j)}`;
        addTileToTileset(
          tilesetMeta,
          autoTilePrefixes[i].biome,
          j,
          new Tile(
            TileType.Terrain,
            tilesetUrl,
            tilesetMeta.color,
            tilesetMeta.id
          )
        );
      }
      addTileToTileset(
        tilesetMeta,
        autoTilePrefixes[i].biome,
        BaseTileKey,
        new Tile(
          TileType.Terrain,
          tilesetMeta.baseTile,
          tilesetMeta.color,
          tilesetMeta.id
        )
      );
    }
  }
  addTileToTileset(
    tilesetMeta,
    "default",
    BaseTileKey,
    new Tile(
      TileType.Terrain,
      tilesetMeta.baseTile,
      tilesetMeta.color,
      tilesetMeta.id
    )
  );
}

export function getCachedTile(sprite: string): CachedSprite {
  const pixiSprite = PIXI.Cache.get(sprite);
  return {
    url: pixiSprite.baseTexture.resource.src,
    xOffset: pixiSprite._frame.x,
    yOffset: pixiSprite._frame.y,
  };
}

function addTileToTileset(
  tilesetMeta: Biome,
  tileAgainstBiome: BiomeId,
  tileIndex: number | string,
  tile: Tile
) {
  // add entry for tileset if it doesn't already exist.
  // it could exist already if other seasons have been added
  if (!Tile.Tilesets[tilesetMeta.id]) {
    Tile.Tilesets[tilesetMeta.id] = {};
  }

  if (!Tile.Tilesets[tilesetMeta.id][tileAgainstBiome]) {
    Tile.Tilesets[tilesetMeta.id][tileAgainstBiome] = {};
  }

  for (const season of AssetSeasons) {
    if (!Tile.Tilesets[tilesetMeta.id][tileAgainstBiome][season]) {
      // add entry for season if it doesn't already exist
      Tile.Tilesets[tilesetMeta.id][tileAgainstBiome][season] = {};
    }
    // add the generated tile to the tileset object
    Tile.Tilesets[tilesetMeta.id][tileAgainstBiome][season][tileIndex] = tile;
  }
}

// function addBaseTileToTileset(tilesetMeta: Biome, tile: Tile) {
//   // add entry for tileset if it doesn't already exist.
//   // it could exist already if other seasons have been added
//   if (!Tile.Tilesets[tilesetMeta.id]) {
//     Tile.Tilesets[tilesetMeta.id] = {};
//   }

//   for (const season of AssetSeasons) {
//     if (!Tile.Tilesets[tilesetMeta.id][season]) {
//       // add entry for season if it doesn't already exist
//       Tile.Tilesets[tilesetMeta.id][season] = {};
//     }
//     // add the generated tile to the tileset object
//     Tile.Tilesets[tilesetMeta.id][season]["base"] = tile;
//   }
// }
